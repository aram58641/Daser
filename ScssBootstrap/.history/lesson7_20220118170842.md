# Bootstrap

## Ֆունկցիաներ

Ֆունկցիան գործիք է, որը նկարագրելով մեկ անգամ կարող է կիրառվել բազմաթիվ անգամներ։ Ֆունկցիաները թույլ են տալիս մեզ օգտագործել կոդի որոշակի հատվածներ տարբեր տեղերում առանց կրկին անգամ վերանկարագրելու։
Ֆունկցիայի անունը ինդենտիֆիկատոր է՝ այչպետք է սկսվի թվային արժեքով, չի կարոպարունակել գծիկ և բացատներ։
Ֆունկցիայի պարամետրերը որոշակի փոփոխականներ են, որոնք փոխանցվում են ֆունկցիային, որպեսզի այն կատարի պահանջվող գործողությունը (կարող է և չունենալ պարամետր)։  
 Ֆունկցիաները բաժանվում են երկու խմբի՝ void և value-type:

```js
function myFunc() {
    console.log("from myFunc function");
}
```

Ֆունկցիայի կանչ
Որպեսզի ֆունկցիան աշխատի անհրաժեշտ է նրա նկատմամբ կիրառել ֆունկցիայի կանչ։ Ֆունկցիայի կանչը թույլ է տալիս աշխատեցնել ֆունկցիան։ Ֆունկցիայի կանչ իրականացնելու համար անհրաժեշտ է գրել ֆունկցիայի անունը, որին պետք է հաջորդի փակագծեր։

```js
function myFunction() {
    console.log("This is a  function");
}
myFunction(); //ֆունկցիայի կանչ
```

## Պարամետրական ֆունկցիա

Որպեսզի ֆունկցիան լինի ունիվերսալ անհրաժեշտ է, որպեսզի այն ստանա պարամետր և կատարի գործողություններ՝ հիմնվելով փոխանցված պարամետրերի վրա։ Եթե ֆունկցիան ունի պարամետր, սակայն նրան պարամետր չի փոխանցվում, ապա այս պարամետրերի արժեքը դառնում է undefined: Այս պարագայում անհրաժեշտ փոփոխականները փոխանցում ենք փակագծերի մեջ:

```js
function sum(a, b) {
    console.log(a + b);
}
sum();
```

Ֆունկցիային հնարավոր է փոխանցել մեկից ավել պարամետրեր։ Այս պարագայում փոխանցվելիք պարամետրերի միջև դրվում է ստորակետ:

```js
function foo(a, b) {
    var sum = a + b;
    alert(sum);
}
foo(5, 7);
```

Արժեք վերադարձնող ֆունկցիաներ (value-type)
Այն ֆունկցիաները, որոնք վերադարձնում են արժեք կոչվում են value-type։ Արժեք վերադարձնող ֆունկցիաները թույլ են տալիս, որպեսզի ֆունկցիայի ներսում հաշվարկված արժեքը կիրառվի նաև ֆունկցիայից դուրս։ Ֆունկցիայի արժեքի վերադարձման պրոցեսը կազմակերպվում է return հրամանի օգնությամբ։ Ֆունկցիայի կանչը կարելի է կիրառել նույն կամ մեկ այլ ֆունկցիայի կիրառմամբ։ return հրամանն անհրաժեշտ է գրել ֆունկցիայի վերջում, քանի որ նրանից հետո գրված այլ կոդ չի աշխատում։

```js
function test() {
    return true;
}
test();
//true
```

Արժեք չվերադարձնող ֆունկցիաներ (void)
Այն ֆունկցիաները, որոնք արժեք չեն վերադարձնում կոչվում են void։

```js
const param1 = true;
const param2 = false;
function twoParams(param1, param2) {
    console.log(param1, param2);
}
```

### Ռեկուրսիվ ֆունկցիաներ

Ռեկուրսիվ է կոչվում այն ֆունկցիան, երբ ֆունկցիայի մարմնում կանչվում է այդ նույն ֆունկցիան։ Ֆունկցիան, որն իրականացնում է ռեկուրսիա, անվանում են ռեկուրսիվ ֆունկցիա։ Ռեկուրսիվ ֆունկցիա մշակելիս առաջին հերթին պետք է համոզվել, որ ֆունկցիան ինչ-որ պահի ավարտվում է։  
 Ռեկուրսիայի կիրառումը կարող է հանգեցնել կոդի ծավալի փոքրացման։
Ռեկուրսիայի օրինակ
Ռեկուրսիվ ֆունկցիայի օրինակ։

```js
// program to count down numbers to 1
function Rec(number) {
    if (number == 1) {
        return 5;
    } else {
        return number * Rec(number * 1);
    }
}
countDown(2);
```

Ռեկուրսիա VS Ցիկլ
Ցիկլը ռեկուրսիայի կիրառման այլընտրանքային տարբերակ է (իտերացիոն եղանակ)։ Բոլոր այն խնդիրները, որոնք կարող են լուծվել ռեկուրսիայի կիրառմամբ, կարող են նաև լուծվել մեզ ծանոթ ցիկլերի միջոցով։ Ռեկուրսիայի շնորհիվ գրված կոդն առավել կարճ է, սակայն այն ավելի դժվար է վերլուծվում և աշխատանքը դանդաղում է։ Ռեկուրսիվ ֆունկցիային ավելացնելով տերնալ օպերատոր, կոդի տեսքը կլինի ավելի պարզ։

```js
function deg1(x,y){
let p = 1;
for (let i = 0; i < y; i++) {
p \*= x
}
return p;
}
deg1(2,3);




function deg2(x,y){
return y == 0 ? 1 : x \* deg2(x, y - 1);
}
deg2(2,3)
// Console.time()-ի օգնությամբ ինքնուրույն ստուգել 2 ֆունկցիաների կատարման ժամանակները
```

Ֆունկցիայի աշխատանքի տևողությունը
Ֆունկցիայի աշխատանքի տևողությունը հաշվարկենք console.time() և console.timeEnd() ֆունկցիաներով։ time ֆունկցիան ստանում է պարամետր, որը կարող է լինել ֆունկցիայի անունը, և սկսում է հաշվել ֆունկցիայի աշխատանքի տևողությունը։ Ֆունկցիայի կանչից հետ անհրաժեշտ է կիրառել timeEnd ֆունկցիան, որին փոխանցված պարամետրը պետք է համընկնի time ֆունկցիայի պարամետրի հետ։ Ֆունկցիան վերադարձնում է միլիվարկյանների քանակը, որն անհրաժեշտ է ֆունկցիայի կանչն իրականացնելու համար։ Ռեկուրսիայի դեպքում ֆունկցիայի աշխատանքի ժամանակն ավելի երկար է, քանի որ ռեկուրսիվ ֆունցիաների աշխատանքը կազմակերպվում է Stack (ստատիկ հիշողություն)-ում, իսկ իտերացիոն եղանակի դեպքում Heap (դինամիկ հիշողություն)-ում։

```js
console.time();
for (i = 0; i < 800; i++) {
    //  code
}
console.timeEnd();
```

## Stack և Heap

Stack-ը և Heap-ը հանդիսանում են RAM-ի (օպերատիվ հիշողության) առանձին մասեր։  
 Heap-ը համակարգչի հիշողության այն մասն է, որն օգտագործվում է դինամիկ հիշողության հատկացման համար, այսինքն, հիշողության բլոկները բաշխվում և տեղաբաշխվում են պատահական եղանակով։
Stack-ում գործընթացները հիմնված են հերթերի գաղափարի վրա։ Այստեղ հիշողության մեջ բաշխվում են ռեկուրսիվ ֆունկցիաների կանչերը, որոնք սկսում են կատարվել հերթականությամբ, որն էլ հանգեցնում է ռեկուրսիայի դանդաղ աշխատանքին։ Երբեմն stack-ում տեղակայված ֆունկցիաների քանակը գերազանցում է սահմանված հիշողությունը, ստանում ենք Error (maximum call stack size exceeded):

## Տնային աշխատանք

1. Ռեկուրսիայի միջոցով հաշվել տրված թվի Ֆակտորիալը։
2. Գրել ֆունկցիա, որը ստուգում է տրված թվի կենտ լինելը։
